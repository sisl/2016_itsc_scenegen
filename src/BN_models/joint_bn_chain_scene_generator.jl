using Smile
using SmileExtra

type JointBNChainSceneGenerator <: OldSceneGenerator
    net        :: Network
    discmap    :: Dict{Symbol, LinearDiscretizer}
    varindeces :: Dict{Symbol, Cint}
    ordering   :: Vector{Int}
end

function train_jointbnchainscenegenerator(scenes::Vector{RoadScene}, nbins::Dict{Symbol, Int},
    bounds :: Dict{Symbol, Tuple{Float64, Float64}} = Dict{Symbol, Tuple{Float64, Float64}}(
        :speed        => (BOUNDS_V_LO,  BOUNDS_V_HI),
        :d_cl         => (BOUNDS_T_LO,  BOUNDS_T_HI),
        :yaw          => (BOUNDS_ϕ_LO,  BOUNDS_ϕ_HI),
        :d_front      => (BOUNDS_ΔD_LO, BOUNDS_ΔD_HI),
        :v_front      => (BOUNDS_ΔV_LO, BOUNDS_ΔV_HI),
        :d_rear       => (BOUNDS_ΔD_LO, BOUNDS_ΔD_HI),
        :v_rear       => (BOUNDS_ΔV_LO, BOUNDS_ΔV_HI)),
    )

    symbols = collect(keys(nbins))
    nvars = length(symbols)
    nscenes = length(scenes)

    ncars = 0
    for scene in scenes
        ncars += length(scene.vehicles)
    end

    varindeces = Dict{Symbol,Cint}()
    discmap = Dict{Symbol, LinearDiscretizer}()
    r_arr = Array(Int, nvars)
    for (i,sym) in enumerate(keys(bounds))
        @assert(in(sym, symbols))
        varindeces[sym] = Int32(i-1)

        nlabels = nbins[sym]
        bins = collect(linspace(bounds[sym][1], bounds[sym][2], nlabels+1))
        discmap[sym] = LinearDiscretizer(bins, Cint)

        r_arr[i] = nlabels
    end

    dmat = Array(Int, nvars, ncars) # NOTE(tim): dmat contains class labels > 0 (ie, 1,2,3,4...)
    add_to_dmat(sym::Symbol, count::Int, val::Float64) =
        dmat[varindeces[sym]+1, count] = encode(discmap[sym], val)

    count = 0
    for scene in scenes

        vehicles = scene.vehicles
        sceneinfo = scene.info

        for (i,veh) in enumerate(vehicles)

            count += 1

            info = sceneinfo[i]
            lane = info.laneindex

            add_to_dmat(:d_cl,          count, info.d_cl)
            add_to_dmat(:yaw,           count, veh.ϕ)
            add_to_dmat(:speed,         count, veh.v)

            if info.carind_fore != 0
                d_front = max(calc_d_front(scene, i), 0.0)
                v_front = scene.vehicles[info.carind_fore].v
                add_to_dmat(:d_front, count, d_front)
                add_to_dmat(:v_front, count, v_front)
            else
                count -= 1
                continue
            end

            if info.carind_rear != 0
                d_rear = max(calc_d_rear(scene, i), 0.0)
                v_rear = scene.vehicles[info.carind_rear].v
                add_to_dmat(:d_rear, count, d_rear)
                add_to_dmat(:v_rear, count, v_rear)
            else
                count -= 1
                continue
            end
        end
    end
    dmat = dmat[:,1:count]

    # structure learning
    params = LearnParams_BayesianSearch()
    params.maxparents  = 5
    params.niterations = 20
    net, worked = learn((dmat-1)', params)
    @assert(worked)

    # add a dirichlet prior and ensure that
    # there are no non-zero probabilities
    net2 = create_new_net_with_prior_counts(net, r_arr, dmat)
    set_default_BN_algorithm(net2, DSL_ALG_BN_LAURITZEN)

    ordering = to_native_int_array(partial_ordering(net)::IntArray)
    JointBNChainSceneGenerator(net2, discmap, varindeces, ordering)
end
function generate_scene(
    sg   :: JointBNChainSceneGenerator,
    sti :: SceneTranslationInfo
    )

    #=
    sg defines a probabilty distribution over
    {v, d_cl, ϕ, d_front, d_rear, v_front, v_rear}

    A scene is generated by generating independent lanes
    A lane is generated by first picking the first vehicle in the scene.
    The next vehicle can be placed by sampling from the distribution conditioned on
    d_rear ← d_front and v_rear ← v and v ← v_front
    This is repeated until the lane is complete.
    =#

    net = sg.net
    discmap = sg.discmap
    varindeces = sg.varindeces

    road = sti.road
    nlanes = road.nlanes
    centers = lanecenters(road)
    roadway = NGSIM.ROADWAY_DICT[sti.roadway_name]

    max_n_vehicles = round(Int, nlanes*roadlength(road) / 10.0) # NOTE(tim): quick and dirty estimate of upper limit
    vehicles = Array(OldVehicle, max_n_vehicles)
    vehiclecount = 0

    veh_2_lane = Int[]
    for lane = 1 : nlanes

        lti = sti.lanes[lane]
        curve = roadway.centerlines[lti.laneid]
        s_lo = curve[lti.curveind_lo].s
        s_hi = curve[lti.curveind_hi].s

        # generate the first vehicle

        center = centers[lane]
        assignment = rand(net, ordering=sg.ordering)::Dict{Cint, Cint}

        d_rear    = decode(discmap[:d_rear],  Int32(assignment[varindeces[:d_rear ]]+1))
        d_front   = decode(discmap[:d_front], Int32(assignment[varindeces[:d_front]]+1))
        v_front   = decode(discmap[:v_front], Int32(assignment[varindeces[:v_front]]+1))
        v         = decode(discmap[:speed],   Int32(assignment[varindeces[:speed  ]]+1))
        d_cl      = decode(discmap[:d_cl],    Int32(assignment[varindeces[:d_cl   ]]+1))
        yaw       = decode(discmap[:yaw],     Int32(assignment[varindeces[:yaw    ]]+1))

        y = d_rear*rand() + s_lo + VEHICLE_MEAN_LENGTH
        vehicles[vehiclecount+=1] = OldVehicle(center+d_cl,y,yaw,v)
        push!(veh_2_lane, lane)

        # now generate vehicles out forward
        while y + d_front + VEHICLE_MEAN_LENGTH < s_hi

            y += d_front + VEHICLE_MEAN_LENGTH

            empty!(assignment)
            assignment[varindeces[:d_rear]] = encode(discmap[:d_rear],  d_front)-1
            assignment[varindeces[:v_rear]] = encode(discmap[:speed],         v)-1
            assignment[varindeces[:speed]]  = encode(discmap[:v_front], v_front)-1

            rand!(net, assignment, ordering=sg.ordering)

            v       = v_front
            d_front = decode(discmap[:d_front], Int32(assignment[varindeces[:d_front]]+1))
            v_front = decode(discmap[:v_front], Int32(assignment[varindeces[:v_front]]+1))
            d_cl    = decode(discmap[:d_cl],    Int32(assignment[varindeces[:d_cl   ]]+1))
            yaw     = decode(discmap[:yaw],     Int32(assignment[varindeces[:yaw    ]]+1))
            vehicles[vehiclecount+=1] = OldVehicle(center+d_cl,y,yaw,v)
            push!(veh_2_lane, lane)
        end
    end

    scene = RoadScene(road, vehicles[1:vehiclecount])
    calc_vehicle_extra_info!(scene)

    for (i, lane) in enumerate(veh_2_lane)
        scene.info[i].laneindex = sti.lanes[lane].laneid
    end

    scene
end
function loglikelihood(
    sg    :: JointBNChainSceneGenerator,
    scene :: RoadScene
    )

    score = 0.0

    net = sg.net
    discmap = sg.discmap
    varindeces = sg.varindeces
    ordering = sg.ordering

    if isempty(scene.info)
        calc_vehicle_extra_info!(scene)
    end

    vehicles  = scene.vehicles
    sceneinfo = scene.info

    nodeid2sym = Dict{Cint, Symbol}()
    for (sym, bmap) in sg.discmap
        nodeid2sym[varindeces[sym]] = sym
    end

    assignment = Dict{Cint,Cint}()
    evidence   = Dict{Cint,Cint}()

    f_assign(d::Dict{Cint,Cint}, sym::Symbol, val::Float64) =
        d[varindeces[sym]] = encode(discmap[sym], val)-1

    bmap_dfront = discmap[:d_front]
    bmap_drear  = discmap[:d_rear]

    node_dfront = varindeces[:d_front]
    node_drear  = varindeces[:d_rear]
    node_speed  = varindeces[:speed]

    binwidths_dfront = binwidths(bmap_dfront)
    binwidths_drear = binwidths(bmap_drear)

    for (carind,veh) in enumerate(scene.vehicles)

        info = scene.info[carind]

        has_car_front = info.carind_fore != 0
        has_car_rear  = info.carind_rear != 0

        if has_car_front && has_car_rear
            # middle of lane
            # P(dcl,ϕ,dfront,vfront|drear,vrear,v)

            f_assign(evidence,   :d_rear,  calc_d_rear(scene, carind))
            f_assign(evidence,   :v_rear,  scene.vehicles[info.carind_rear].v)
            f_assign(evidence,   :speed,   veh.v)

            delete!(assignment, node_speed)
            f_assign(assignment, :d_cl,    info.d_cl)
            f_assign(assignment, :yaw,     veh.ϕ)
            f_assign(assignment, :d_front, calc_d_front(scene, carind))
            f_assign(assignment, :v_front, scene.vehicles[info.carind_fore].v)

            probvec = probabilities(net, assignment, evidence, ordering=ordering)
            for (nodeid, prob) in probvec
                w  = binwidth(discmap[nodeid2sym[nodeid]], Int32(assignment[nodeid]+1))
                score += log(prob / w)
                if isinf(score) # DEBUG
                    println("A INF! ", w, "  ", prob)
                end
            end

        elseif has_car_front
            # first car in lane
            # P(dcl,ϕ,dfront,vfront,v)
            # P(offset_y)

            f_assign(assignment, :speed,   veh.v)
            f_assign(assignment, :d_cl,    info.d_cl)
            f_assign(assignment, :yaw,     veh.ϕ)
            f_assign(assignment, :d_front, calc_d_front(scene, carind))
            f_assign(assignment, :v_front, scene.vehicles[info.carind_fore].v)

            probvec = probabilities(net, assignment, ordering=ordering)
            for (nodeid, prob) in probvec
                w  = binwidth(discmap[nodeid2sym[nodeid]], Int32(assignment[nodeid]+1))
                score += log(prob / w)
                if isinf(score) # DEBUG
                    println("B INF! ", w, "  ", prob)
                end
            end

            offset_y = veh.y + scene.road.horizon_rear
            probvec_drear = normalize!(get_marginal_probability_vec(net, node_drear, assignment)) ./ binwidths_drear
            score += log(prob_gen(offset_y, Inf, bmap_drear.binedges, probvec_drear ))
            if isinf(score) # DEBUG
                println("C INF! ", offset_y, "  ", probvec_drear)
            end

        elseif has_car_rear
            # last car in lane
            # P(dcl,ϕ|drear,vrear,v)
            # P(dfront > offset_end)

            f_assign(evidence,   :d_rear,  calc_d_rear(scene, carind))
            f_assign(evidence,   :v_rear,  scene.vehicles[info.carind_rear].v)
            f_assign(evidence,   :speed,   veh.v)

            empty!(assignment)
            f_assign(assignment, :d_cl,    info.d_cl)
            f_assign(assignment, :yaw,     veh.ϕ)

            probvec = probabilities(net, assignment, evidence, ordering=ordering)
            for (nodeid, prob) in probvec
                w  = binwidth(discmap[nodeid2sym[nodeid]], Int32(assignment[nodeid]+1))
                score += log(prob / w)
                if isinf(score) # DEBUG
                    println("D INF! ", w, "  ", prob)
                end
            end

            offset_end = scene.road.horizon_fore - veh.y - VEHICLE_MEAN_LENGTH
            if offset_end > 0.0
                probvec_dfront = normalize!(get_marginal_probability_vec(net, node_dfront, merge(assignment, evidence))) ./ binwidths_dfront
                score += log(prob_gt(offset_end, bmap_dfront.binedges, probvec_dfront))
                if isinf(score) # DEBUG
                    println("E INF! ", offset_y, "  ", probvec_drear)
                end
            end
        else
            # only car in lane
            # P(dcl,ϕ,v)
            # P(offset_y)
            # P(dfront > offset_end)

            empty!(assignment)
            f_assign(assignment, :d_cl,  info.d_cl)
            f_assign(assignment, :yaw,   veh.ϕ)
            f_assign(assignment, :speed, veh.v)

            probvec = probabilities(net, assignment, ordering=ordering)
            for (nodeid, prob) in probvec
                w  = binwidth(discmap[nodeid2sym[nodeid]], Int32(assignment[nodeid]+1))
                score += log(prob / w)
                if isinf(score) # DEBUG
                    println("F INF! ", w, "  ", prob)
                end
            end

            offset_y = veh.y + scene.road.horizon_rear
            probvec_drear = normalize!(get_marginal_probability_vec(net, node_drear, assignment)) ./ binwidths_drear
            score += log(prob_gen(offset_y, Inf, bmap_drear.binedges, probvec_drear ))
            if isinf(score) # DEBUG
                println("G INF! ", offset_y, "  ", probvec_drear)
            end

            offset_end = scene.road.horizon_fore - veh.y - VEHICLE_MEAN_LENGTH
            if offset_end > 0.0
                probvec_dfront = normalize!(get_marginal_probability_vec(net, node_dfront, assignment)) ./ binwidths_dfront
                score += log(prob_gt(offset_end, bmap_dfront.binedges, probvec_dfront))
                if isinf(score) # DEBUG
                    println("H INF! ", offset_end, "  ", probvec_dfront)
                end
            end
        end

        @assert(!isinf(score))
    end

    score
end

train{T<:JointBNChainSceneGenerator}(res::ModelOptimizationResults{T}, roadscenes::Vector{RoadScene}) =
    train_jointbnchainscenegenerator(roadscenes, convert(Dict{Symbol,Int}, res.params))

function cross_validate(
    ::Type{JointBNChainSceneGenerator},
    roadscenes::Vector{RoadScene},
    nbins::Dict{Symbol,Int};
    CV_nfolds :: Int = 10, # k in k-fold cross validations
    CV_rounds :: Int = 10  # number of CV evals to do
    )

    println("nbins")
    println(nbins)

    scores = cross_validate_scenegenerator(JointBNChainSceneGenerator, roadscenes, nbins, CV_rounds = CV_rounds, CV_nfolds =CV_nfolds)
    μ, σ = ave_crossvalidated_likelihood(scores)
    (μ, σ)
end
function cross_validate_scenegenerator(
    ::Type{JointBNChainSceneGenerator},
    roadscenes::Vector{RoadScene},
    nbins     :: Dict{Symbol, Int};
    CV_nfolds :: Int = 4, # k in k-fold cross validations
    CV_rounds :: Int = 4, # number of CV evals to do

    )

    nscenes = length(roadscenes)

    f_train(inds::Vector{Int}) = train_jointbnchainscenegenerator(roadscenes[inds], nbins)
    f_test(sg::SceneGenerator, inds::Vector{Int}) = begin
        score = 0.0
        for ind in inds
            score += loglikelihood(sg, roadscenes[ind])
        end
        score
    end

    scores = Array(Float64, CV_nfolds, CV_rounds)
    for round = 1 : CV_rounds
        for (fold, train_inds) in enumerate(Kfold(nscenes, CV_nfolds))
            # print("set!")
            test_inds = setdiff(1:nscenes, train_inds)
            # println(" [DONE]")
            # print("training!")
            model = f_train(train_inds)
            # println(" [DONE]")
            # print("logl!")
            scores[fold,round] = f_test(model, test_inds)
            # println(" [DONE]")
        end
    end

    # println("Done with a round !")

    scores
end
function cyclic_coordinate_ascent_parallel(
    T::Type{JointBNChainSceneGenerator},
    roadscenes::Vector{RoadScene};
    CV_nfolds::Int = 10,
    CV_rounds::Int = 10,
    )

    param_options = (
            [4,5,6], # [3,5,7,10,15,20], # 25,30], # :speed
            [10,12,15], #[3,5,7,10,15,20] # 25,30], # :d_cl
            [17,20,25,30], #[3,5,7,10,15,20], # 25,30], # :yaw
            [8,9,10],# [3,5,7,10,15,20], # 25,30], # :d_front
            [17,20,25,30], #[3,5,7,10,15,20], # 25,30], # :d_rear
            [15,20,25,30], # 25,30], # :v_front
            [17,20,25,30], #[3,5,7,10,15,20], # 25,30], # :v_rear
        )

    n_params = length(param_options)
    paraminds = ones(Int, n_params)
    for i = 1 : n_params
        if length(param_options[i]) > 1
            paraminds[i] = round(Int, length(param_options[i])/2)
        end
    end
    params_tried = Set{Vector{Int}}()

    converged  = false
    best_score = -Inf
    best_μ     = NaN
    best_σ     = NaN
    iter = 0
    while !converged
        iter += 1
        println("iteration: ", iter)

        converged = true
        for coordinate = 1 : n_params
            println("\tcoordinate: ", coordinate)

            to_try = Vector{Int}[]
            ip_arr = Int[]
            for ip in 1 : length(param_options[coordinate])

                newparams = copy(paraminds)
                newparams[coordinate] = ip

                if !in(newparams, params_tried)
                    push!(params_tried, newparams)
                    push!(ip_arr, ip)
                    push!(to_try, newparams)
                end
            end

            if !isempty(to_try)

                tic()
                scores = map(to_try) do newparams # WAS pmap
                    cross_validate(T, roadscenes,
                       Dict(
                        :speed    => param_options[1][newparams[1]],
                        :d_cl     => param_options[2][newparams[2]],
                        :yaw      => param_options[3][newparams[3]],
                        :d_front  => param_options[4][newparams[4]],
                        :d_rear   => param_options[5][newparams[5]],
                        :v_front  => param_options[6][newparams[6]],
                        :v_rear   => param_options[7][newparams[7]],
                        ),CV_rounds = CV_rounds, CV_nfolds =CV_nfolds)
                end
                toc()


                run_ind = 0
                run_score = -Inf
                run_μ = NaN
                run_σ = NaN
                for i = 1 : length(scores)
                    μ = scores[i][1]
                    σ = scores[i][2]
                    score = μ
                    if score > run_score
                        run_ind, run_μ, run_σ, run_score = i, μ, σ, score
                    end
                end

                if run_score > best_score
                    best_score = run_score
                    best_μ, best_σ = run_μ, run_σ
                    paraminds[coordinate] = ip_arr[run_ind]
                    converged = false
                    println("\tfound better: ", coordinate, " -> ", param_options[coordinate][ip_arr[run_ind]])
                    println(paraminds)
                    println("\t\tscore: ", best_score)
                end
            end
        end
    end

    println("done!")
    println("optimal params: ", )
    println("\tnbins_speed    = ", param_options[1][paraminds[1]])
    println("\tnbins_d_cl     = ", param_options[2][paraminds[2]])
    println("\tnbins_yaw      = ", param_options[3][paraminds[3]])
    println("\tnbins_d_front  = ", param_options[4][paraminds[4]])
    println("\tnbins_d_rear   = ", param_options[5][paraminds[5]])
    println("\tnbins_v_front  = ", param_options[6][paraminds[6]])
    println("\tnbins_v_rear   = ", param_options[7][paraminds[7]])
    println("score: ", best_score)
    println("iter:  ", iter)

    opt_params = Dict{Symbol,Any}()
    opt_params[:speed  ] = param_options[1][paraminds[1]]
    opt_params[:d_cl   ] = param_options[2][paraminds[2]]
    opt_params[:yaw    ] = param_options[3][paraminds[3]]
    opt_params[:d_front] = param_options[4][paraminds[4]]
    opt_params[:d_rear ] = param_options[5][paraminds[5]]
    opt_params[:v_front] = param_options[6][paraminds[6]]
    opt_params[:v_rear ] = param_options[7][paraminds[7]]

    ModelOptimizationResults{T}(opt_params, best_μ, best_σ, best_score, iter, CV_nfolds, CV_rounds)
end